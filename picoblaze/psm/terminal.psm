;;;
;;; serial terminal
;;;
	address 500  ; ONLY FOR STANDALONE VERSION


;;; terminal stuff
	CONSTANT cur_line, 60	;cursor line   0-39
	CONSTANT cur_col, 61	;cursor column 0-79

	CONSTANT first_row, 01	;normally zero but our display malfunctions

	CONSTANT nrows, 40'd
	CONSTANT last_row, 39'd
	CONSTANT ncols, 80'd
	CONSTANT last_col, 79'd

	CONSTANT vram_data_in, 0d
	CONSTANT vram_data_out, 09
	CONSTANT vram_addr_lo, 0a    ; column
	CONSTANT vram_addr_hi, 0b    ; row
	CONSTANT vram_wr, 0d

	CONSTANT video_ctrl, 10
	CONSTANT cursor_col, 11
	CONSTANT cursor_row, 12

	;; bits in control register
	CONSTANT video_red, 01
	CONSTANT video_green, 02
	CONSTANT video_blue, 04
	CONSTANT cur_mode, 10
	CONSTANT cur_blink, 20
	CONSTANT cur_en, 40
	CONSTANT vga_en, 80

	CONSTANT mode_set, e7	;dpy enabled, cursor on, blink color=white

	jump cmd_T

;;;----------------------------------------
;;; jump vectors to monitor
;;; ----------------------------------------
m_start: jump 000		; 000: cold start
m_last:	jump 001		; 001: top of program
m_main:	jump 002		; 002: warm start
m_UART_RX_wait:	jump 003	; 003: UART input (s5)
m_UART_TX: jump 004		; 004: UART output
m_send_hex_byte: jump 005 ; 005: send hex output (s4)
m_send_message:	jump 006  ; 006: send message from (sA, sB)

;;; set up for terminal action
;;; overall register use:
;;;   s8 - current column \ cursor position
;;;   s9 - current row    / memory address
;;;   sA - 01 for writing to RAM
cmd_T:
	;; initial hardware set up - pretty simple
	load s0, mode_set
	output s0, video_ctrl
	load sA, 01

	call cls		;clear
	call home		;home cursor

termi:	call dpcur		;update cursor display
	call m_UART_RX_wait	;get input character to s5
	;; check for escape
	compare s5, 03		;^C
	jump z, m_main
	compare s5, 1b		;ESC
	jump z, m_main
	
	call m_UART_TX		;echo the char
	
	;; check for a control chars
	compare s5,0d		;CR?
	jump z,term_cr
	compare s5,0a		;LF?
	jump z,term_lf
	
	call v_putc
	jump termi

;;; display character in s5 at cursor
;;; move cursor right
v_putc:	output s8,vram_addr_lo	;set column RAM address
	output s9,vram_addr_hi	;set row RAM address
	output s5,vram_data_out	;set output data
	output sA,vram_wr	;write to VRAM
	add s8, 01		;increment column
	compare s8, ncols	;did we just wrap?
	jump nz, dpcur
	load s8, 00		;reset to first column
	;; this is also the entry point for a LF from anywhere
dolf:	add s9, 01		;of next row
	compare s9, nrows	;off bottom of screen?
	jump nz, dpcur

	sub s9, 01		;back to last row
	;; scroll the screen up
	call scroll
	
dpcur: 	add s8,01		;why?
	output s8, cursor_col	;update cursor posn
	sub s8,01
	output s9, cursor_row
	return

;;; scroll the entire screen up
;;; FIXME: write this
scroll:	return

term_cr:
	load s8,00
	jump termi

	;; LF
term_lf: call dolf
	jump termi

;;; home cursor
home:	
	load s8,00
	load s9,first_row
	return
	
	;; clear the screen
	;; uses s0, s2, s3, s4
cls:	load s2, 00
	load s3, 00

	output s3, vram_addr_hi
	load s0, 20		;space character
	output s0, vram_data_out
	load s4, 01		;write bit

crl:	output s2, vram_addr_lo
	output s4, vram_wr
	add s2, 01
	compare s2, ncols
	jump nz, crl

	load s2,00
	add s3,01
	output s3, vram_addr_hi
	compare s3, nrows
	jump nz, crl

	jump home
	
	;; scroll screen between lines s2, s3 up a line
	;; s2 - first line, increments as "copy from"
	;;      ("copy to" is s2-1)
	;; s3 - end line for checking
	;; s4 - constant 01 for write ops
	;; s1 - column
	
scrlin:	load s4, 01		;write bit
	load s1, 00		;column
	;; check for same value
	compare s2, s3
	return z		;null operation if s2==s3

	;; start by incre

	;; copy a line from line s2 to line s3
	;; uses s0, s1, s4
movlin:	load s4,01		;write strobe
	load s1,00		;column

	;; 18 clocks * 80 = 57us
movchr:	output s1,vram_addr_lo
	output s2,vram_addr_hi
	input s0, vram_data_in
	output s3,vram_addr_hi
	output s0, vram_data_out
	output s4, vram_wr
	add s1,01
	compare s1,ncols
	jump nz, movchr

